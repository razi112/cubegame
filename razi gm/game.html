<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cube Surf 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB; /* Sky blue fallback */
            touch-action: none; /* Prevent browser scrolling on mobile */
        }
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas if needed, mostly for UI overlay */
        }
        #score-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 28px;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            letter-spacing: 1px;
        }
        #coin-container {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #FFD700;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            transition: opacity 0.3s;
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        h1 {
            color: white;
            font-size: 4rem;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            font-style: italic;
            text-shadow: 4px 4px 0 #ff0055;
            text-align: center;
            line-height: 1;
        }
        p {
            color: #eee;
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            max-width: 80%;
        }
        .controls-hint {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        .key {
            background: rgba(255,255,255,0.2);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            border: 2px solid rgba(255,255,255,0.4);
        }
        button.btn {
            background: linear-gradient(to bottom, #ffcc00, #ffaa00);
            color: #3d2b00;
            padding: 15px 50px;
            font-size: 24px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #b37700, 0 10px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button.btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #b37700, 0 4px 4px rgba(0,0,0,0.3);
        }
        #final-score-display {
            color: white;
            font-size: 2rem;
            margin-bottom: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-layer">
        <div id="score-container">SCORE: <span id="score">0</span></div>
        <div id="coin-container">COINS: <span id="coins">0</span></div>

        <div id="start-screen" class="screen">
            <h1>Cube Surf<br>3D</h1>
            <div class="controls-hint">
                <div class="key">← Lane</div>
                <div class="key">↑ Jump</div>
                <div class="key">↓ Roll</div>
                <div class="key">→ Lane</div>
            </div>
            <p>Swipe on mobile / Use Arrow Keys on Desktop</p>
            <button class="btn" id="start-btn">START RUN</button>
        </div>

        <div id="game-over-screen" class="screen hidden">
            <h1>CRASHED!</h1>
            <div id="final-score-display">Score: 0</div>
            <button class="btn" id="restart-btn">TRY AGAIN</button>
        </div>
    </div>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Game Configuration ---
        const CONFIG = {
            laneWidth: 3,
            lanes: [-3, 0, 3], // x-coordinates for Left, Center, Right
            playerSpeed: 0.2, // Visual lerp speed for lane changing
            runningSpeed: 0.6, // Base world movement speed
            maxSpeed: 1.2,
            speedIncrement: 0.0001,
            jumpForce: 0.42, // Increased for snappier jump
            gravity: 0.025,  // Increased gravity for less "floaty" feel
            groundLength: 200,
            fogColor: 0x87CEEB,
            colors: {
                player: 0x00d2ff,
                ground: 0x333333,
                obstacle: 0xff4444,
                coin: 0xffd700,
                building: 0x555555
            }
        };

        // --- Global Variables ---
        let scene, camera, renderer;
        let player, playerMesh, playerCollider;
        let groundParts = [];
        let obstacles = [];
        let coins = [];
        let scenery = [];
        let particles = [];
        
        let gameState = {
            isPlaying: false,
            score: 0,
            coinCount: 0,
            speed: CONFIG.runningSpeed,
            lane: 1, // 0: Left, 1: Center, 2: Right
            isJumping: false,
            isRolling: false,
            verticalVelocity: 0,
            distance: 0,
            rollTimer: 0
        };

        const scoreEl = document.getElementById('score');
        const coinsEl = document.getElementById('coins');
        const finalScoreEl = document.getElementById('final-score-display');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');

        // --- Initialization ---
        function init() {
            // Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.fogColor);
            scene.fog = new THREE.Fog(CONFIG.fogColor, 20, 90);

            // Setup Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 0, -10);

            // Setup Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            createPlayer();
            createGround();
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeyDown);
            setupTouchControls();

            // UI Buttons
            document.getElementById('start-btn').addEventListener('click', startGame);
            document.getElementById('restart-btn').addEventListener('click', resetGame);

            // Start Render Loop
            animate();
        }

        // --- Game Object Creation ---

        function createPlayer() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({ 
                color: CONFIG.colors.player,
                shininess: 100 
            });
            player = new THREE.Group();
            playerMesh = new THREE.Mesh(geometry, material);
            playerMesh.castShadow = true;
            playerMesh.position.y = 0.5; // Sit on ground
            player.add(playerMesh);
            scene.add(player);
            
            // Collider helper (invisible)
            playerCollider = new THREE.Box3();
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(CONFIG.groundLength, CONFIG.groundLength);
            const material = new THREE.MeshPhongMaterial({ 
                color: CONFIG.colors.ground,
                depthWrite: false 
            });
            
            // Create two ground planes for infinite scrolling illusion
            for(let i=0; i<2; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.z = -i * CONFIG.groundLength;
                mesh.receiveShadow = true;
                scene.add(mesh);
                groundParts.push(mesh);
            }
            
            // Lane markers
            const lineGeo = new THREE.PlaneGeometry(0.2, CONFIG.groundLength);
            const lineMat = new THREE.MeshBasicMaterial({ color: 0x555555 });
            
            [-1.5, 1.5].forEach(x => {
                for(let i=0; i<2; i++) {
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(x, 0.01, -i * CONFIG.groundLength);
                    scene.add(line);
                    groundParts.push(line); // Move with ground
                }
            });
        }

        function spawnObstacle(zPos) {
            // Randomly choose a lane (0, 1, or 2)
            const laneIndex = Math.floor(Math.random() * 3);
            const xPos = CONFIG.lanes[laneIndex];
            
            // Type of obstacle: 0 = Low Barrier (Jump), 1 = High Barrier (Roll/Duck - represented by floating box), 2 = Full Block (Move Lane)
            const type = Math.random();

            let geometry, material, mesh;
            let isRollingObstacle = false;

            if (type < 0.4) {
                // Low Barrier (Must Jump Over)
                geometry = new THREE.BoxGeometry(2, 0.8, 0.5);
                material = new THREE.MeshPhongMaterial({ color: CONFIG.colors.obstacle });
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(xPos, 0.4, zPos);
            } else if (type < 0.7) {
                // High Barrier (Must Roll Under)
                // Lowered this visually so it looks like it hits your head (Center Y=1.1, Height=1.0 covers Y=0.6 to 1.6)
                geometry = new THREE.BoxGeometry(2, 1.0, 0.5); 
                material = new THREE.MeshPhongMaterial({ color: CONFIG.colors.obstacle });
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(xPos, 1.1, zPos); 
                isRollingObstacle = true;
            } else {
                // Train/Wall (Must Switch Lane)
                geometry = new THREE.BoxGeometry(2.5, 2.5, 4);
                material = new THREE.MeshPhongMaterial({ color: 0xcc3333 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(xPos, 1.25, zPos);
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            obstacles.push({ mesh, type: isRollingObstacle ? 'high' : 'normal', active: true });

            // Chance to spawn coins in OTHER lanes
            [0, 1, 2].forEach(l => {
                if (l !== laneIndex && Math.random() > 0.6) {
                    spawnCoin(CONFIG.lanes[l], zPos);
                }
            });
        }

        function spawnCoin(x, z) {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: CONFIG.colors.coin, 
                emissive: 0xaa6600,
                shininess: 100 
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0.5, z);
            scene.add(mesh);
            coins.push({ mesh, active: true });
        }

        function spawnScenery(zPos) {
            // Simple buildings on the sides
            if (Math.random() > 0.3) return;

            const side = Math.random() > 0.5 ? 1 : -1;
            const x = side * (10 + Math.random() * 5);
            const height = 5 + Math.random() * 15;
            const geometry = new THREE.BoxGeometry(4, height, 4);
            const material = new THREE.MeshPhongMaterial({ color: CONFIG.colors.building });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, height/2, zPos);
            scene.add(mesh);
            scenery.push(mesh);
        }

        function createExplosion(pos, color) {
            const particleCount = 10;
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<particleCount; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(pos);
                mesh.position.x += (Math.random() - 0.5);
                mesh.position.y += (Math.random() - 0.5);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                scene.add(mesh);
                particles.push({ mesh, velocity, life: 1.0 });
            }
        }

        // --- Game Logic Updates ---

        function updatePlayer() {
            if (!gameState.isPlaying) return;

            // Lateral Movement (Lerp)
            const targetX = CONFIG.lanes[gameState.lane];
            player.position.x += (targetX - player.position.x) * CONFIG.playerSpeed;

            // Rotation effect when changing lanes
            const tilt = (player.position.x - targetX) * 0.2;
            player.rotation.z = tilt;
            player.rotation.y = -tilt * 0.5;

            // Jumping Physics
            if (gameState.isJumping) {
                player.position.y += gameState.verticalVelocity;
                gameState.verticalVelocity -= CONFIG.gravity;

                if (player.position.y <= 0) {
                    player.position.y = 0;
                    gameState.isJumping = false;
                    gameState.verticalVelocity = 0;
                    
                    // Reset Squash/Stretch
                    playerMesh.scale.set(1, 1, 1);
                    playerMesh.position.y = 0.5;
                }
            } else if (!gameState.isRolling) {
                // Normal running bounce
                player.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.1;
            }

            // Rolling Logic
            if (gameState.isRolling) {
                gameState.rollTimer--;
                if (gameState.rollTimer <= 0) {
                    gameState.isRolling = false;
                    // Stand up animation
                    playerMesh.scale.y = 1;
                    playerMesh.position.y = 0.5;
                } else {
                    // Stay crouched
                    playerMesh.scale.y = 0.5;
                    playerMesh.position.y = 0.25;
                }
            }
        }

        function updateWorld() {
            if (!gameState.isPlaying) return;

            // Increase speed
            if (gameState.speed < CONFIG.maxSpeed) {
                gameState.speed += CONFIG.speedIncrement;
            }

            gameState.distance += gameState.speed;
            scoreEl.innerText = Math.floor(gameState.distance);

            // Move Ground
            groundParts.forEach(part => {
                part.position.z += gameState.speed;
                if (part.position.z > 50) {
                    part.position.z -= CONFIG.groundLength * 2;
                }
            });

            // Move Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.mesh.position.z += gameState.speed;

                // Collision Detection
                // Simple AABB
                // Player box approximation:
                // X: player.position.x +/- 0.4
                // Y: player.position.y + (isRolling ? 0.25 : 0.5) +/- size
                // Z: player.position.z (0) +/- 0.4
                
                // We check if obstacle is close in Z
                if (obs.active && Math.abs(obs.mesh.position.z - player.position.z) < 1.0) {
                    
                    // Check X overlap
                    if (Math.abs(obs.mesh.position.x - player.position.x) < 1.0) {
                        
                        let collision = false;
                        
                        if (obs.type === 'normal') {
                            // Low Barrier: Jump Over
                            // Collision if player feet are lower than obstacle top (0.8)
                            // We give a tiny buffer (0.75) to be forgiving
                            if (player.position.y < 0.75) {
                                collision = true;
                            }
                        } else if (obs.type === 'high') {
                            // High Barrier: Roll Under
                            // Obstacle range Y: [0.6, 1.6]
                            // Player Standing Head: 1.0 -> Collision
                            // Player Rolling Head: 0.5 -> Safe (under 0.6)
                            // Player Jumping: Head > 1.0 -> Collision (unless you jump super high over it, which isn't intended)
                            
                            if (!gameState.isRolling) {
                                collision = true;
                            }
                        }

                        if (collision) {
                            gameOver();
                        }
                    }
                }

                // Cleanup
                if (obs.mesh.position.z > 10) {
                    scene.remove(obs.mesh);
                    obstacles.splice(i, 1);
                }
            }

            // Move Coins
            for (let i = coins.length - 1; i >= 0; i--) {
                let coin = coins[i];
                coin.mesh.position.z += gameState.speed;
                coin.mesh.rotation.y += 0.1;

                // Collection
                if (coin.active && 
                    Math.abs(coin.mesh.position.z - player.position.z) < 1.0 && 
                    Math.abs(coin.mesh.position.x - player.position.x) < 1.0) {
                    
                    // Collect!
                    coin.active = false;
                    scene.remove(coin.mesh);
                    coins.splice(i, 1);
                    
                    gameState.coinCount++;
                    coinsEl.innerText = gameState.coinCount;
                    createExplosion(player.position, 0xffd700);
                    continue;
                }

                if (coin.mesh.position.z > 10) {
                    scene.remove(coin.mesh);
                    coins.splice(i, 1);
                }
            }

            // Move Scenery
            for (let i = scenery.length - 1; i >= 0; i--) {
                let b = scenery[i];
                b.position.z += gameState.speed;
                if (b.position.z > 20) {
                    scene.remove(b);
                    scenery.splice(i, 1);
                }
            }

            // Spawning Logic
            // Spawn based on distance or random frames?
            // Let's spawn roughly every 30-50 units
            const lastObs = obstacles.length > 0 ? obstacles[obstacles.length-1].mesh.position.z : 10;
            // Note: Obstacles spawn at negative Z (e.g. -100) and move to positive Z
            // So the 'last' spawned is the most negative number.
            
            // Find the obstacle with lowest Z (furthest away)
            let minZ = -50;
            if (obstacles.length > 0) {
                minZ = Math.min(...obstacles.map(o => o.mesh.position.z));
            }
            
            // If the furthest obstacle is closer than -80, spawn a new one at -100
            if (minZ > -80) {
                spawnObstacle(-100 - Math.random() * 20);
                spawnScenery(-100 - Math.random() * 20);
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.life -= 0.05;
                p.mesh.position.add(p.velocity);
                p.mesh.scale.setScalar(p.life);
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            updateWorld();
            updateParticles();
            
            renderer.render(scene, camera);
        }

        // --- Controls ---

        function handleInput(action) {
            if (!gameState.isPlaying) return;

            switch(action) {
                case 'left':
                    if (gameState.lane > 0) gameState.lane--;
                    break;
                case 'right':
                    if (gameState.lane < 2) gameState.lane++;
                    break;
                case 'up':
                    if (!gameState.isJumping) {
                        gameState.isJumping = true;
                        gameState.verticalVelocity = CONFIG.jumpForce;
                        // Cancel roll if jumping
                        if (gameState.isRolling) {
                            gameState.isRolling = false;
                            playerMesh.scale.y = 1;
                            playerMesh.position.y = 0.5;
                        }
                    }
                    break;
                case 'down':
                    if (!gameState.isRolling && !gameState.isJumping) {
                        gameState.isRolling = true;
                        gameState.rollTimer = 40; // frames
                    } else if (gameState.isJumping) {
                        // Fast fall
                        gameState.verticalVelocity = -0.5;
                    }
                    break;
            }
        }

        function handleKeyDown(e) {
            if (e.key === 'ArrowLeft' || e.key === 'a') handleInput('left');
            if (e.key === 'ArrowRight' || e.key === 'd') handleInput('right');
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') handleInput('up');
            if (e.key === 'ArrowDown' || e.key === 's') handleInput('down');
        }

        function setupTouchControls() {
            let touchStartX = 0;
            let touchStartY = 0;

            document.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, false);

            document.addEventListener('touchend', e => {
                let touchEndX = e.changedTouches[0].screenX;
                let touchEndY = e.changedTouches[0].screenY;
                
                handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
            }, false);
        }

        function handleSwipe(sx, sy, ex, ey) {
            const dx = ex - sx;
            const dy = ey - sy;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);

            if (Math.max(absDx, absDy) < 20) return; // Tap, ignore

            if (absDx > absDy) {
                // Horizontal
                if (dx > 0) handleInput('right');
                else handleInput('left');
            } else {
                // Vertical
                if (dy > 0) handleInput('down');
                else handleInput('up');
            }
        }

        // --- Game Flow State ---

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            resetGameState();
            gameState.isPlaying = true;
            
            // Initial obstacles
            obstacles.forEach(o => scene.remove(o.mesh));
            coins.forEach(c => scene.remove(c.mesh));
            scenery.forEach(s => scene.remove(s));
            obstacles = [];
            coins = [];
            scenery = [];
            
            for(let i=0; i<5; i++) {
                spawnObstacle(-50 - i * 30);
            }
        }

        function resetGameState() {
            gameState.score = 0;
            gameState.coinCount = 0;
            gameState.distance = 0;
            gameState.speed = CONFIG.runningSpeed;
            gameState.lane = 1;
            gameState.isJumping = false;
            gameState.isRolling = false;
            gameState.verticalVelocity = 0;
            
            player.position.set(0, 0, 0);
            playerMesh.scale.set(1, 1, 1);
            playerMesh.position.y = 0.5;

            scoreEl.innerText = '0';
            coinsEl.innerText = '0';
        }

        function gameOver() {
            gameState.isPlaying = false;
            finalScoreEl.innerText = "Score: " + Math.floor(gameState.distance) + " | Coins: " + gameState.coinCount;
            gameOverScreen.classList.remove('hidden');
            createExplosion(player.position, CONFIG.colors.player);
        }

        function resetGame() {
            startGame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Run
        init();

    </script>
</body>
</html>